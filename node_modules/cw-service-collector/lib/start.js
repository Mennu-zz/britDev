
var pkg = require(__dirname + '/../package.json')
var fs = require('fs')
var colors = require('colors')
var util = require(__dirname + '/util.js')
var express = require('express')
var pushApp = null // will be an instance of express, if there are any push collectors
var bodyParser = require('body-parser')
var multer = require('multer')
var path = require('path')
var mqclient = require('mqclient/amqp')


module.exports = function () {

  if (util.serviceIsRunning()) {
    console.log('Collector service already running')
    process.exit()
  }
  else {

    var pidFile = path.normalize(process.cwd() + '/' + '.pid')
    fs.writeFileSync(pidFile, process.pid)

    var config = require(process.cwd() + '/collector-service.json')
    //console.log(config)

    var collectorDirs = fs.readdirSync(process.cwd())

    // load each collector
    collectorDirs.forEach(function (file) {

      // collector directory
      var filePath = process.cwd() + '/' + file

      // collectors HAVE to be in their respective directories
      if (config.exclude.indexOf(file) == -1 && fs.statSync(filePath).isDirectory()) {

        var collectorName = file
        var apiPrefixCode


        var processedFilePath = filePath + '/.collector'
        var processedCode

        var collectorCode = fs.readFileSync(filePath + '/index.js')
        var collectorConfig = util.getConfigObject(filePath + '/index.js')
        var collectorLog = fs.openSync(filePath + '/collector.log', 'a');
        var collectorInstance

        // validate all processorConfig values
        var validation = util.validateConfig(collectorConfig)
        //console.log(collectorConfig)
        //console.log(validation)
        // all valid
        if (validation[0]) {

          // it's a PUSH COLLECTOR
          // Do the work of listening for connections and data, on behalf of the collector
          if (collectorConfig.mode === 'push') {

            // construct the API prefix code
            apiPrefixCode = fs.readFileSync(__dirname + '/api/push.template').toString().replace('% collectorDir %', __dirname)

            // make the Collector Service API available to the collector
            processedCode = apiPrefixCode + '\n' + collectorCode

            // this file will be run as an independent collector process
            fs.writeFileSync(processedFilePath, processedCode)

            // fork the child
            collectorInstance = require('child_process').spawn('node', [processedFilePath], {
              cwd: process.cwd(),
              env: process.env,
              stdio: ['ignore', collectorLog, collectorLog, 'ipc']
            })

            if (!pushApp) {
              pushApp = express()
              pushApp.use(bodyParser.json())
              pushApp.use(bodyParser.urlencoded({ extended: true }))
              pushApp.use(multer())
            }

            var collectorPath = '/' + collectorName

            // # keep a reference of the request objects and their ids
            var requestQueue = {
              counter: 0,
              ref: {}
            }

            // create web interface for the collector
            // # relay the request to the collector
            pushApp[( collectorConfig.method ? collectorConfig.method.toLowerCase() : 'post' )](collectorPath, function (req, res, next) {

              // need this to send the response after getting the message from the child process
              requestQueue.counter++
              requestQueue.ref[requestQueue.counter] = req

              //console.log(req)

              // create a reduced version of the req object for the collector
              var requestObject = {

                id: requestQueue.counter, // reference id of the request, the child process should send this back
                cookies: req.cookies,
                ip: req.ip,
                ips: req.ips,
                path: req.path,
                body: req.body || {},
                params: req.params || {},
                files: req.files || {},
                query: req.query || {}

              }
              // send the request object to the collector
              collectorInstance.send(requestObject)

            })

            // listen for response from the collector
            collectorInstance.on('message', function (msg) {

              msg = JSON.parse(msg)

              var res = requestQueue.ref[msg.id].res
              res.status(msg.code).send(msg.message)

              var collectorAddress = 'collector:' + collectorConfig.mode + ':' + collectorName
              var collectorData = JSON.stringify(msg)

              // broadcast only if the data is accepted
              if (msg.code == 200) {

                //console.log(collectorAddress)
                //console.log(collectorData)

                // broadcast the data - will be caught by processors subscribed to the collector

                mqclient.pub(collectorAddress, collectorData, function () {
                  console.log('PUSH COLLECTOR BROADCASTED: %s', collectorAddress)
                  console.log(collectorData)
                })

              }

            })

            // // catch any error
            // collectorInstance.on('error', function (err) {
            //   throw new Error(err)
            // })

            // // track instance status
            // collectorInstance.on('exit', function (err) {
            //   console.log('%s exited'.red, collectorName)
            // })

            console.log('%s started'.yellow, collectorName)

          }
          // it's a PULL COLLECTOR
          // the collector API does the work of fetching the data
          // just broadcast the status when the data is received by the collector
          else {

            // construct the API prefix code
            apiPrefixCode = fs.readFileSync(__dirname + '/api/pull.template').toString().replace('% collectorDir %', __dirname)

            // make the Collector Service API available to the collector
            processedCode = apiPrefixCode + '\n' + collectorCode

            // this file will be run as an independent collector process
            fs.writeFileSync(processedFilePath, processedCode)

            // fork the child
            collectorInstance = require('child_process').spawn('node', [processedFilePath], {
              cwd: process.cwd(),
              env: process.env,
              stdio: ['ignore', collectorLog, collectorLog, 'ipc']
            })

            // # Collector will make its own request and inform when result comes
            // listen for response from the collector
            collectorInstance.on('message', function (message) {

              //console.log('GOT MESSAGE FROM COLLECTOR')
              //console.log(_message)
              //var message = JSON.parse(_message)
              //console.log(message)

              var collectorAddress = 'collector:' + collectorConfig.mode + ':' + collectorName
              var collectorMessage = ''
              var _collectorMessage = ''

              // broadcast only if the data is accepted
              if (message.code == 0) {
                //console.log(message)

                collectorMessage = {
                  body: message.body,
                  origin: {
                    type: 'collector',
                    name: collectorAddress
                  },
                  time: Date.now()
                }

                _collectorMessage = JSON.stringify(collectorMessage)

                //console.log(collectorAddress)
                //console.log(collectorMessage)

                // broadcast the data - will be caught by processors subscribed to the collector
                //console.log('HERE')
                mqclient.pub(collectorAddress, _collectorMessage, function () {
                  //console.log('PULL COLLECTOR BROADCASTED: %s', collectorAddress)
                  //console.log(collectorMessage)
                })

              }
              else {
                // throw new Error(message.body)
              }

            })

            // catch any error
            collectorInstance.on('error', function (err) {
              throw new Error(err)
            })

            // track instance status
            collectorInstance.on('exit', function (err) {
              console.log('%s exited'.red, collectorName)
            })

            // pull collectors should listen on refreshRequestChannel for refresh requests
            var refreshRequestChannel = 'collector:' + collectorConfig.mode + ':' + collectorName + ':refresh'

            mqclient.sub(refreshRequestChannel, function (err, params) {

              if (err) {
                throw new Error(err)
              }
              else {
                //console.log('refreshRequestChannel:', refreshRequestChannel)
                //console.log(params)
                var collectorAddress = 'collector:' + collectorConfig.mode + ':' + collectorName
                collectorInstance.send(params) // handled by api/index.js/pull
              }

            })

            console.log('%s started'.yellow, collectorName)
          }
        }
        // config validation failed
        else {
          console.log('%s failed to start'.red, collectorName)
          // show the validation fail message
          console.log(validation[1].grey)
        }

      }

    })

    // create a push server ONLY if there are any push collectors
    if (pushApp) {

      var server = pushApp.listen(config.port, function () {
        //console.log(server.address())
        //console.log('Push collector server started at %d', config.port)
      })
    }




  }

}

